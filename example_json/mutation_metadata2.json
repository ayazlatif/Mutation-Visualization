[{"mutated_lineno":27,"mutated_output":"        quotient = x / y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return x\n\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3","productive":true,"mutation_operator":"AOD","equivalent":true,"mutated_output_lineno":22,"unmutated_output":"        quotient = x / y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return -x\n\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3","killers":[["test_negate (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 28, in test_negate\n    self.assertEqual(self.sut.negate(operand), -operand, \"Incorrect Calculator.negate.\")\nAssertionError: Incorrect Calculator.negate.\n"]],"unmutated_output_lineno":22,"mutant_name":"mutant_AOD_UnaryOp_0","killed":true,"mutated_ast_node":"UnaryOp"},{"mutated_lineno":5,"mutated_output":"class Calculator(object):\n\n    @classmethod\n    def add(cls, x, y):\n        sum = x // y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":1,"unmutated_output":"class Calculator(object):\n\n    @classmethod\n    def add(cls, x, y):\n        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y","killers":[["test_add (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 12, in test_add\n    self.assertEqual(self.sut.add(operand1, operand2), 9, \"Incorrect Calculator.add.\")\nAssertionError: Incorrect Calculator.add.\n"]],"unmutated_output_lineno":1,"mutant_name":"mutant_AOR_BinOp_1","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":5,"mutated_output":"class Calculator(object):\n\n    @classmethod\n    def add(cls, x, y):\n        sum = x / y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":1,"unmutated_output":"class Calculator(object):\n\n    @classmethod\n    def add(cls, x, y):\n        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y","killers":[["test_add (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 12, in test_add\n    self.assertEqual(self.sut.add(operand1, operand2), 9, \"Incorrect Calculator.add.\")\nAssertionError: Incorrect Calculator.add.\n"]],"unmutated_output_lineno":1,"mutant_name":"mutant_AOR_BinOp_2","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":5,"mutated_output":"class Calculator(object):\n\n    @classmethod\n    def add(cls, x, y):\n        sum = x * y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":1,"unmutated_output":"class Calculator(object):\n\n    @classmethod\n    def add(cls, x, y):\n        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y","killers":[["test_add (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 12, in test_add\n    self.assertEqual(self.sut.add(operand1, operand2), 9, \"Incorrect Calculator.add.\")\nAssertionError: Incorrect Calculator.add.\n"]],"unmutated_output_lineno":1,"mutant_name":"mutant_AOR_BinOp_3","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":5,"mutated_output":"class Calculator(object):\n\n    @classmethod\n    def add(cls, x, y):\n        sum = x - y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":1,"unmutated_output":"class Calculator(object):\n\n    @classmethod\n    def add(cls, x, y):\n        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y","killers":[["test_add (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 12, in test_add\n    self.assertEqual(self.sut.add(operand1, operand2), 9, \"Incorrect Calculator.add.\")\nAssertionError: Incorrect Calculator.add.\n"]],"unmutated_output_lineno":1,"mutant_name":"mutant_AOR_BinOp_4","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":10,"mutated_output":"        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x // y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":5,"unmutated_output":"        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y","killers":[["test_sub (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 16, in test_sub\n    self.assertEqual(self.sut.subtract(operand1, operand2), -1, \"Incorrect Calculator.subtract.\")\nAssertionError: Incorrect Calculator.subtract.\n"]],"unmutated_output_lineno":5,"mutant_name":"mutant_AOR_BinOp_5","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":10,"mutated_output":"        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x / y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":5,"unmutated_output":"        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y","killers":[["test_sub (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 16, in test_sub\n    self.assertEqual(self.sut.subtract(operand1, operand2), -1, \"Incorrect Calculator.subtract.\")\nAssertionError: Incorrect Calculator.subtract.\n"]],"unmutated_output_lineno":5,"mutant_name":"mutant_AOR_BinOp_6","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":10,"mutated_output":"        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x * y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":5,"unmutated_output":"        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y","killers":[["test_sub (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 16, in test_sub\n    self.assertEqual(self.sut.subtract(operand1, operand2), -1, \"Incorrect Calculator.subtract.\")\nAssertionError: Incorrect Calculator.subtract.\n"]],"unmutated_output_lineno":5,"mutant_name":"mutant_AOR_BinOp_7","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":10,"mutated_output":"        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x + y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":5,"unmutated_output":"        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y","killers":[["test_sub (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 16, in test_sub\n    self.assertEqual(self.sut.subtract(operand1, operand2), -1, \"Incorrect Calculator.subtract.\")\nAssertionError: Incorrect Calculator.subtract.\n"]],"unmutated_output_lineno":5,"mutant_name":"mutant_AOR_BinOp_8","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":15,"mutated_output":"        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x // y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":10,"unmutated_output":"        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:","killers":[["test_mult (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 20, in test_mult\n    self.assertEqual(self.sut.multiply(operand1, operand2), 20, \"Incorrect Calculator.multiply.\")\nAssertionError: Incorrect Calculator.multiply.\n"]],"unmutated_output_lineno":10,"mutant_name":"mutant_AOR_BinOp_9","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":15,"mutated_output":"        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x / y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":10,"unmutated_output":"        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:","killers":[["test_mult (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 20, in test_mult\n    self.assertEqual(self.sut.multiply(operand1, operand2), 20, \"Incorrect Calculator.multiply.\")\nAssertionError: Incorrect Calculator.multiply.\n"]],"unmutated_output_lineno":10,"mutant_name":"mutant_AOR_BinOp_10","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":15,"mutated_output":"        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x - y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":10,"unmutated_output":"        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:","killers":[["test_mult (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 20, in test_mult\n    self.assertEqual(self.sut.multiply(operand1, operand2), 20, \"Incorrect Calculator.multiply.\")\nAssertionError: Incorrect Calculator.multiply.\n"]],"unmutated_output_lineno":10,"mutant_name":"mutant_AOR_BinOp_11","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":15,"mutated_output":"        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x + y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":10,"unmutated_output":"        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:","killers":[["test_mult (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 20, in test_mult\n    self.assertEqual(self.sut.multiply(operand1, operand2), 20, \"Incorrect Calculator.multiply.\")\nAssertionError: Incorrect Calculator.multiply.\n"]],"unmutated_output_lineno":10,"mutant_name":"mutant_AOR_BinOp_12","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":22,"mutated_output":"\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x // y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return -x","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":17,"unmutated_output":"\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return -x","killers":[],"unmutated_output_lineno":17,"mutant_name":"mutant_AOR_BinOp_13","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":22,"mutated_output":"\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x * y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return -x","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":17,"unmutated_output":"\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return -x","killers":[["test_div (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 24, in test_div\n    self.assertEqual(self.sut.divide(operand1, operand2), 0, \"Incorrect Calculator.divide.\")\nAssertionError: Incorrect Calculator.divide.\n"]],"unmutated_output_lineno":17,"mutant_name":"mutant_AOR_BinOp_14","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":22,"mutated_output":"\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x - y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return -x","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":17,"unmutated_output":"\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return -x","killers":[["test_div (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 24, in test_div\n    self.assertEqual(self.sut.divide(operand1, operand2), 0, \"Incorrect Calculator.divide.\")\nAssertionError: Incorrect Calculator.divide.\n"]],"unmutated_output_lineno":17,"mutant_name":"mutant_AOR_BinOp_15","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":22,"mutated_output":"\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x + y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return -x","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":17,"unmutated_output":"\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return -x","killers":[["test_div (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 24, in test_div\n    self.assertEqual(self.sut.divide(operand1, operand2), 0, \"Incorrect Calculator.divide.\")\nAssertionError: Incorrect Calculator.divide.\n"]],"unmutated_output_lineno":17,"mutant_name":"mutant_AOR_BinOp_16","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":39,"mutated_output":"        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x / y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":34,"unmutated_output":"        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x // y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:","killers":[],"unmutated_output_lineno":34,"mutant_name":"mutant_AOR_BinOp_17","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":39,"mutated_output":"        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x * y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":34,"unmutated_output":"        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x // y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:","killers":[["test_floorDiv (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 34, in test_floorDiv\n    self.assertEqual(self.sut.floorDiv(operand1, operand2), 2, \"Incorrect Calculator.floorDiv\")\nAssertionError: Incorrect Calculator.floorDiv\n"]],"unmutated_output_lineno":34,"mutant_name":"mutant_AOR_BinOp_18","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":39,"mutated_output":"        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x - y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":34,"unmutated_output":"        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x // y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:","killers":[["test_floorDiv (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 34, in test_floorDiv\n    self.assertEqual(self.sut.floorDiv(operand1, operand2), 2, \"Incorrect Calculator.floorDiv\")\nAssertionError: Incorrect Calculator.floorDiv\n"]],"unmutated_output_lineno":34,"mutant_name":"mutant_AOR_BinOp_19","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":39,"mutated_output":"        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x + y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":34,"unmutated_output":"        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x // y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:","killers":[["test_floorDiv (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 34, in test_floorDiv\n    self.assertEqual(self.sut.floorDiv(operand1, operand2), 2, \"Incorrect Calculator.floorDiv\")\nAssertionError: Incorrect Calculator.floorDiv\n"]],"unmutated_output_lineno":34,"mutant_name":"mutant_AOR_BinOp_20","killed":true,"mutated_ast_node":"BinOp"},{"mutated_lineno":94,"mutated_output":"    def get_version(cls):\n        version = '1.2.3'\n        return version\n\n    @classmethod\n    def divide_positiveInt(cls, x, y):\n        if x >= y > 0:\n            quotient = x // y\n            return quotient\n        else:\n            return None","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":89,"unmutated_output":"    def get_version(cls):\n        version = '1.2.3'\n        return version\n\n    @classmethod\n    def divide_positiveInt(cls, x, y):\n        if x >= y > 0:\n            quotient = x / y\n            return quotient\n        else:\n            return None","killers":[],"unmutated_output_lineno":89,"mutant_name":"mutant_AOR_BinOp_21","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":94,"mutated_output":"    def get_version(cls):\n        version = '1.2.3'\n        return version\n\n    @classmethod\n    def divide_positiveInt(cls, x, y):\n        if x >= y > 0:\n            quotient = x * y\n            return quotient\n        else:\n            return None","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":89,"unmutated_output":"    def get_version(cls):\n        version = '1.2.3'\n        return version\n\n    @classmethod\n    def divide_positiveInt(cls, x, y):\n        if x >= y > 0:\n            quotient = x / y\n            return quotient\n        else:\n            return None","killers":[],"unmutated_output_lineno":89,"mutant_name":"mutant_AOR_BinOp_22","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":94,"mutated_output":"    def get_version(cls):\n        version = '1.2.3'\n        return version\n\n    @classmethod\n    def divide_positiveInt(cls, x, y):\n        if x >= y > 0:\n            quotient = x - y\n            return quotient\n        else:\n            return None","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":89,"unmutated_output":"    def get_version(cls):\n        version = '1.2.3'\n        return version\n\n    @classmethod\n    def divide_positiveInt(cls, x, y):\n        if x >= y > 0:\n            quotient = x / y\n            return quotient\n        else:\n            return None","killers":[],"unmutated_output_lineno":89,"mutant_name":"mutant_AOR_BinOp_23","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":94,"mutated_output":"    def get_version(cls):\n        version = '1.2.3'\n        return version\n\n    @classmethod\n    def divide_positiveInt(cls, x, y):\n        if x >= y > 0:\n            quotient = x + y\n            return quotient\n        else:\n            return None","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":89,"unmutated_output":"    def get_version(cls):\n        version = '1.2.3'\n        return version\n\n    @classmethod\n    def divide_positiveInt(cls, x, y):\n        if x >= y > 0:\n            quotient = x / y\n            return quotient\n        else:\n            return None","killers":[],"unmutated_output_lineno":89,"mutant_name":"mutant_AOR_BinOp_24","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":141,"mutated_output":"    def add(self, x, y):\n        \"\"\"\n        Override add function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x // y\n\n    def subtract(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":136,"unmutated_output":"    def add(self, x, y):\n        \"\"\"\n        Override add function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x + y\n\n    def subtract(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":136,"mutant_name":"mutant_AOR_BinOp_25","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":141,"mutated_output":"    def add(self, x, y):\n        \"\"\"\n        Override add function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x / y\n\n    def subtract(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":136,"unmutated_output":"    def add(self, x, y):\n        \"\"\"\n        Override add function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x + y\n\n    def subtract(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":136,"mutant_name":"mutant_AOR_BinOp_26","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":141,"mutated_output":"    def add(self, x, y):\n        \"\"\"\n        Override add function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x * y\n\n    def subtract(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":136,"unmutated_output":"    def add(self, x, y):\n        \"\"\"\n        Override add function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x + y\n\n    def subtract(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":136,"mutant_name":"mutant_AOR_BinOp_27","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":141,"mutated_output":"    def add(self, x, y):\n        \"\"\"\n        Override add function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x - y\n\n    def subtract(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":136,"unmutated_output":"    def add(self, x, y):\n        \"\"\"\n        Override add function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x + y\n\n    def subtract(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":136,"mutant_name":"mutant_AOR_BinOp_28","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":150,"mutated_output":"    def subtract(self, x, y):\n        \"\"\"\n        Override subtract function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x // y\n\n    def multiply(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":145,"unmutated_output":"    def subtract(self, x, y):\n        \"\"\"\n        Override subtract function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x - y\n\n    def multiply(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":145,"mutant_name":"mutant_AOR_BinOp_29","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":150,"mutated_output":"    def subtract(self, x, y):\n        \"\"\"\n        Override subtract function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x / y\n\n    def multiply(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":145,"unmutated_output":"    def subtract(self, x, y):\n        \"\"\"\n        Override subtract function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x - y\n\n    def multiply(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":145,"mutant_name":"mutant_AOR_BinOp_30","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":150,"mutated_output":"    def subtract(self, x, y):\n        \"\"\"\n        Override subtract function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x * y\n\n    def multiply(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":145,"unmutated_output":"    def subtract(self, x, y):\n        \"\"\"\n        Override subtract function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x - y\n\n    def multiply(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":145,"mutant_name":"mutant_AOR_BinOp_31","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":150,"mutated_output":"    def subtract(self, x, y):\n        \"\"\"\n        Override subtract function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x + y\n\n    def multiply(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":145,"unmutated_output":"    def subtract(self, x, y):\n        \"\"\"\n        Override subtract function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x - y\n\n    def multiply(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":145,"mutant_name":"mutant_AOR_BinOp_32","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":159,"mutated_output":"    def multiply(self, x, y):\n        \"\"\"\n        Override multiply function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x // y\n\n    def divide(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":154,"unmutated_output":"    def multiply(self, x, y):\n        \"\"\"\n        Override multiply function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x * y\n\n    def divide(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":154,"mutant_name":"mutant_AOR_BinOp_33","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":159,"mutated_output":"    def multiply(self, x, y):\n        \"\"\"\n        Override multiply function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x / y\n\n    def divide(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":154,"unmutated_output":"    def multiply(self, x, y):\n        \"\"\"\n        Override multiply function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x * y\n\n    def divide(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":154,"mutant_name":"mutant_AOR_BinOp_34","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":159,"mutated_output":"    def multiply(self, x, y):\n        \"\"\"\n        Override multiply function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x - y\n\n    def divide(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":154,"unmutated_output":"    def multiply(self, x, y):\n        \"\"\"\n        Override multiply function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x * y\n\n    def divide(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":154,"mutant_name":"mutant_AOR_BinOp_35","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":159,"mutated_output":"    def multiply(self, x, y):\n        \"\"\"\n        Override multiply function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x + y\n\n    def divide(self, x, y):\n        \"\"\"","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":154,"unmutated_output":"    def multiply(self, x, y):\n        \"\"\"\n        Override multiply function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x * y\n\n    def divide(self, x, y):\n        \"\"\"","killers":[],"unmutated_output_lineno":154,"mutant_name":"mutant_AOR_BinOp_36","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":168,"mutated_output":"    def divide(self, x, y):\n        \"\"\"\n        Override divide function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x // y\n\n\nclass CalculatorTest(object):","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":163,"unmutated_output":"    def divide(self, x, y):\n        \"\"\"\n        Override divide function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x / y\n\n\nclass CalculatorTest(object):","killers":[],"unmutated_output_lineno":163,"mutant_name":"mutant_AOR_BinOp_37","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":168,"mutated_output":"    def divide(self, x, y):\n        \"\"\"\n        Override divide function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x * y\n\n\nclass CalculatorTest(object):","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":163,"unmutated_output":"    def divide(self, x, y):\n        \"\"\"\n        Override divide function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x / y\n\n\nclass CalculatorTest(object):","killers":[],"unmutated_output_lineno":163,"mutant_name":"mutant_AOR_BinOp_38","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":168,"mutated_output":"    def divide(self, x, y):\n        \"\"\"\n        Override divide function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x - y\n\n\nclass CalculatorTest(object):","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":163,"unmutated_output":"    def divide(self, x, y):\n        \"\"\"\n        Override divide function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x / y\n\n\nclass CalculatorTest(object):","killers":[],"unmutated_output_lineno":163,"mutant_name":"mutant_AOR_BinOp_39","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":168,"mutated_output":"    def divide(self, x, y):\n        \"\"\"\n        Override divide function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x + y\n\n\nclass CalculatorTest(object):","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":163,"unmutated_output":"    def divide(self, x, y):\n        \"\"\"\n        Override divide function defined in Calculator\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return x / y\n\n\nclass CalculatorTest(object):","killers":[],"unmutated_output_lineno":163,"mutant_name":"mutant_AOR_BinOp_40","killed":false,"mutated_ast_node":"BinOp"},{"mutated_lineno":27,"mutated_output":"        quotient = x / y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return +x\n\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3","productive":false,"mutation_operator":"AOR","equivalent":false,"mutated_output_lineno":22,"unmutated_output":"        quotient = x / y\n        return quotient\n\n    @classmethod\n    def negate(cls, x):\n        return -x\n\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3","killers":[["test_negate (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 28, in test_negate\n    self.assertEqual(self.sut.negate(operand), -operand, \"Incorrect Calculator.negate.\")\nAssertionError: Incorrect Calculator.negate.\n"]],"unmutated_output_lineno":22,"mutant_name":"mutant_AOR_UnaryOp_41","killed":true,"mutated_ast_node":"UnaryOp"},{"mutated_lineno":53,"mutated_output":"\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x /= y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":48,"unmutated_output":"\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x //= y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'","killers":[],"unmutated_output_lineno":48,"mutant_name":"mutant_ASR_AugAssign_42","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":53,"mutated_output":"\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x *= y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":48,"unmutated_output":"\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x //= y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'","killers":[["test_floorDivAssign (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 38, in test_floorDivAssign\n    self.assertEqual(self.sut.floorDivAssign(operand1, operand2), 2, \"Incorrect Calculator.floorDivAssign\")\nAssertionError: Incorrect Calculator.floorDivAssign\n"]],"unmutated_output_lineno":48,"mutant_name":"mutant_ASR_AugAssign_43","killed":true,"mutated_ast_node":"AugAssign"},{"mutated_lineno":53,"mutated_output":"\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x -= y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":48,"unmutated_output":"\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x //= y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'","killers":[["test_floorDivAssign (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 38, in test_floorDivAssign\n    self.assertEqual(self.sut.floorDivAssign(operand1, operand2), 2, \"Incorrect Calculator.floorDivAssign\")\nAssertionError: Incorrect Calculator.floorDivAssign\n"]],"unmutated_output_lineno":48,"mutant_name":"mutant_ASR_AugAssign_44","killed":true,"mutated_ast_node":"AugAssign"},{"mutated_lineno":53,"mutated_output":"\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x += y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":48,"unmutated_output":"\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x //= y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'","killers":[["test_floorDivAssign (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 38, in test_floorDivAssign\n    self.assertEqual(self.sut.floorDivAssign(operand1, operand2), 2, \"Incorrect Calculator.floorDivAssign\")\nAssertionError: Incorrect Calculator.floorDivAssign\n"]],"unmutated_output_lineno":48,"mutant_name":"mutant_ASR_AugAssign_45","killed":true,"mutated_ast_node":"AugAssign"},{"mutated_lineno":72,"mutated_output":"        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res //= nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":67,"unmutated_output":"        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res += nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res","killers":[],"unmutated_output_lineno":67,"mutant_name":"mutant_ASR_AugAssign_46","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":72,"mutated_output":"        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res /= nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":67,"unmutated_output":"        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res += nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res","killers":[],"unmutated_output_lineno":67,"mutant_name":"mutant_ASR_AugAssign_47","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":72,"mutated_output":"        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res *= nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":67,"unmutated_output":"        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res += nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res","killers":[],"unmutated_output_lineno":67,"mutant_name":"mutant_ASR_AugAssign_48","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":72,"mutated_output":"        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res -= nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":67,"unmutated_output":"        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res += nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res","killers":[],"unmutated_output_lineno":67,"mutant_name":"mutant_ASR_AugAssign_49","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":82,"mutated_output":"        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res //= nums[i]\n            i += 1\n        return res\n","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":77,"unmutated_output":"        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n","killers":[],"unmutated_output_lineno":77,"mutant_name":"mutant_ASR_AugAssign_50","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":82,"mutated_output":"        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res /= nums[i]\n            i += 1\n        return res\n","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":77,"unmutated_output":"        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n","killers":[],"unmutated_output_lineno":77,"mutant_name":"mutant_ASR_AugAssign_51","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":82,"mutated_output":"        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res *= nums[i]\n            i += 1\n        return res\n","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":77,"unmutated_output":"        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n","killers":[],"unmutated_output_lineno":77,"mutant_name":"mutant_ASR_AugAssign_52","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":82,"mutated_output":"        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res -= nums[i]\n            i += 1\n        return res\n","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":77,"unmutated_output":"        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n","killers":[],"unmutated_output_lineno":77,"mutant_name":"mutant_ASR_AugAssign_53","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":83,"mutated_output":"\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i //= 1\n        return res\n\n    @classmethod","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":78,"unmutated_output":"\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n\n    @classmethod","killers":[],"unmutated_output_lineno":78,"mutant_name":"mutant_ASR_AugAssign_54","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":83,"mutated_output":"\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i /= 1\n        return res\n\n    @classmethod","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":78,"unmutated_output":"\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n\n    @classmethod","killers":[],"unmutated_output_lineno":78,"mutant_name":"mutant_ASR_AugAssign_55","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":83,"mutated_output":"\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i *= 1\n        return res\n\n    @classmethod","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":78,"unmutated_output":"\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n\n    @classmethod","killers":[],"unmutated_output_lineno":78,"mutant_name":"mutant_ASR_AugAssign_56","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":83,"mutated_output":"\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i -= 1\n        return res\n\n    @classmethod","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":78,"unmutated_output":"\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n\n    @classmethod","killers":[],"unmutated_output_lineno":78,"mutant_name":"mutant_ASR_AugAssign_57","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":128,"mutated_output":"        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res //= anum\n        return res\n\n","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":123,"unmutated_output":"        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n\n","killers":[],"unmutated_output_lineno":123,"mutant_name":"mutant_ASR_AugAssign_58","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":128,"mutated_output":"        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res /= anum\n        return res\n\n","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":123,"unmutated_output":"        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n\n","killers":[],"unmutated_output_lineno":123,"mutant_name":"mutant_ASR_AugAssign_59","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":128,"mutated_output":"        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res *= anum\n        return res\n\n","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":123,"unmutated_output":"        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n\n","killers":[],"unmutated_output_lineno":123,"mutant_name":"mutant_ASR_AugAssign_60","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":128,"mutated_output":"        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res -= anum\n        return res\n\n","productive":false,"mutation_operator":"ASR","equivalent":false,"mutated_output_lineno":123,"unmutated_output":"        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n\n","killers":[],"unmutated_output_lineno":123,"mutant_name":"mutant_ASR_AugAssign_61","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":70,"mutated_output":"    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                break\n            res += nums[i]\n            res = cls.add(res, nums[i])","productive":false,"mutation_operator":"BCR","equivalent":false,"mutated_output_lineno":65,"unmutated_output":"    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res += nums[i]\n            res = cls.add(res, nums[i])","killers":[],"unmutated_output_lineno":65,"mutant_name":"mutant_BCR_Continue_62","killed":false,"mutated_ast_node":"Continue"},{"mutated_lineno":33,"mutated_output":"\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3\n        z = cls.multiply(x=xx & yy, y=0)\n        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:","productive":false,"mutation_operator":"LOD","equivalent":false,"mutated_output_lineno":28,"unmutated_output":"\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3\n        z = cls.multiply(x=not xx & yy, y=0)\n        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:","killers":[],"unmutated_output_lineno":28,"mutant_name":"mutant_LOD_UnaryOp_63","killed":false,"mutated_ast_node":"UnaryOp"},{"mutated_lineno":65,"mutated_output":"                print 'unknown exception'\n        finally:\n            pass\n\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):","productive":false,"mutation_operator":"LOD","equivalent":false,"mutated_output_lineno":60,"unmutated_output":"                print 'unknown exception'\n        finally:\n            pass\n\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):","killers":[],"unmutated_output_lineno":60,"mutant_name":"mutant_LOD_UnaryOp_64","killed":false,"mutated_ast_node":"UnaryOp"},{"mutated_lineno":65,"mutated_output":"                print 'unknown exception'\n        finally:\n            pass\n\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):","productive":false,"mutation_operator":"LOI","equivalent":false,"mutated_output_lineno":60,"unmutated_output":"                print 'unknown exception'\n        finally:\n            pass\n\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):","killers":[],"unmutated_output_lineno":60,"mutant_name":"mutant_LOI_UnaryOp_65","killed":false,"mutated_ast_node":"UnaryOp"},{"mutated_lineno":51,"mutated_output":"        finally:\n            pass\n\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if not (y == 0 and True):\n                    return None\n                x //= y\n                return x","productive":false,"mutation_operator":"LOI","equivalent":false,"mutated_output_lineno":46,"unmutated_output":"        finally:\n            pass\n\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x //= y\n                return x","killers":[["test_floorDivAssign (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 38, in test_floorDivAssign\n    self.assertEqual(self.sut.floorDivAssign(operand1, operand2), 2, \"Incorrect Calculator.floorDivAssign\")\nAssertionError: Incorrect Calculator.floorDivAssign\n"]],"unmutated_output_lineno":46,"mutant_name":"mutant_LOI_BoolOp_66","killed":true,"mutated_ast_node":"BoolOp"},{"mutated_lineno":184,"mutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [3, 1, 5, 2, 6]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","productive":false,"mutation_operator":"CDL","equivalent":false,"mutated_output_lineno":179,"unmutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","killers":[],"unmutated_output_lineno":179,"mutant_name":"mutant_CDL_List_67","killed":false,"mutated_ast_node":"List"},{"mutated_lineno":184,"mutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [1, 5, 2, 6, 4]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","productive":false,"mutation_operator":"CDL","equivalent":false,"mutated_output_lineno":179,"unmutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","killers":[],"unmutated_output_lineno":179,"mutant_name":"mutant_CDL_List_68","killed":false,"mutated_ast_node":"List"},{"mutated_lineno":184,"mutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [5, 2, 6, 4, 3]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","productive":false,"mutation_operator":"CDL","equivalent":false,"mutated_output_lineno":179,"unmutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","killers":[],"unmutated_output_lineno":179,"mutant_name":"mutant_CDL_List_69","killed":false,"mutated_ast_node":"List"},{"mutated_lineno":184,"mutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [2, 6, 4, 3, 1]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","productive":false,"mutation_operator":"CDL","equivalent":false,"mutated_output_lineno":179,"unmutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","killers":[],"unmutated_output_lineno":179,"mutant_name":"mutant_CDL_List_70","killed":false,"mutated_ast_node":"List"},{"mutated_lineno":184,"mutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [6, 4, 3, 1, 5]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","productive":false,"mutation_operator":"CDL","equivalent":false,"mutated_output_lineno":179,"unmutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","killers":[],"unmutated_output_lineno":179,"mutant_name":"mutant_CDL_List_71","killed":false,"mutated_ast_node":"List"},{"mutated_lineno":184,"mutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","productive":false,"mutation_operator":"CDL","equivalent":false,"mutated_output_lineno":179,"unmutated_output":"    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]\n    Calculator.sum_all(nums)\n    print res\n    sc = ScientificCalculator()","killers":[],"unmutated_output_lineno":179,"mutant_name":"mutant_CDL_List_72","killed":false,"mutated_ast_node":"List"},{"mutated_lineno":41,"mutated_output":"    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x // y\n                return quotient\n            except ZeroDivisionError:\n                pass\n            except:\n                print 'unknown exception'\n        finally:","productive":false,"mutation_operator":"EXS","equivalent":false,"mutated_output_lineno":36,"unmutated_output":"    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x // y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:\n                print 'unknown exception'\n        finally:","killers":[],"unmutated_output_lineno":36,"mutant_name":"mutant_EXS_ExceptHandler_73","killed":false,"mutated_ast_node":"ExceptHandler"},{"mutated_lineno":43,"mutated_output":"        try:\n            try:\n                quotient = x // y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:\n                pass\n        finally:\n            pass\n","productive":false,"mutation_operator":"EXS","equivalent":false,"mutated_output_lineno":38,"unmutated_output":"        try:\n            try:\n                quotient = x // y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:\n                print 'unknown exception'\n        finally:\n            pass\n","killers":[],"unmutated_output_lineno":38,"mutant_name":"mutant_EXS_ExceptHandler_74","killed":false,"mutated_ast_node":"ExceptHandler"},{"mutated_lineno":55,"mutated_output":"    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x //= y\n                return x\n            except ZeroDivisionError:\n                pass\n            except:\n                print 'unknown exception'","productive":false,"mutation_operator":"EXS","equivalent":false,"mutated_output_lineno":50,"unmutated_output":"    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x //= y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:\n                print 'unknown exception'","killers":[],"unmutated_output_lineno":50,"mutant_name":"mutant_EXS_ExceptHandler_75","killed":false,"mutated_ast_node":"ExceptHandler"},{"mutated_lineno":57,"mutated_output":"            try:\n                if y == 0 and True:\n                    return None\n                x //= y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:\n                pass\n        finally:\n            pass","productive":false,"mutation_operator":"EXS","equivalent":false,"mutated_output_lineno":52,"unmutated_output":"            try:\n                if y == 0 and True:\n                    return None\n                x //= y\n                return x\n            except ZeroDivisionError:\n                print 'divided by zero'\n            except:\n                print 'unknown exception'\n        finally:\n            pass","killers":[],"unmutated_output_lineno":52,"mutant_name":"mutant_EXS_ExceptHandler_76","killed":false,"mutated_ast_node":"ExceptHandler"},{"mutated_lineno":51,"mutated_output":"        finally:\n            pass\n\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 or True:\n                    return None\n                x //= y\n                return x","productive":false,"mutation_operator":"LCR","equivalent":false,"mutated_output_lineno":46,"unmutated_output":"        finally:\n            pass\n\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x //= y\n                return x","killers":[["test_floorDivAssign (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 38, in test_floorDivAssign\n    self.assertEqual(self.sut.floorDivAssign(operand1, operand2), 2, \"Incorrect Calculator.floorDivAssign\")\nAssertionError: Incorrect Calculator.floorDivAssign\n"]],"unmutated_output_lineno":46,"mutant_name":"mutant_LCR_BoolOp_77","killed":true,"mutated_ast_node":"BoolOp"},{"mutated_lineno":101,"mutated_output":"            quotient = x / y\n            return quotient\n        else:\n            return None\n\n    @classmethod\n    def bit_negate(cls, x):\n        return x\n\n    @classmethod\n    def bit_and(cls, x, y):","productive":false,"mutation_operator":"BOD","equivalent":false,"mutated_output_lineno":96,"unmutated_output":"            quotient = x / y\n            return quotient\n        else:\n            return None\n\n    @classmethod\n    def bit_negate(cls, x):\n        return ~x\n\n    @classmethod\n    def bit_and(cls, x, y):","killers":[],"unmutated_output_lineno":96,"mutant_name":"mutant_BOD_UnaryOp_78","killed":false,"mutated_ast_node":"UnaryOp"},{"mutated_lineno":33,"mutated_output":"\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3\n        z = cls.multiply(x=not xx | yy, y=0)\n        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:","productive":false,"mutation_operator":"BOR","equivalent":false,"mutated_output_lineno":28,"unmutated_output":"\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3\n        z = cls.multiply(x=not xx & yy, y=0)\n        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:","killers":[],"unmutated_output_lineno":28,"mutant_name":"mutant_BOR_BitAnd_79","killed":false,"mutated_ast_node":"BitAnd"},{"mutated_lineno":105,"mutated_output":"\n    @classmethod\n    def bit_negate(cls, x):\n        return ~x\n\n    @classmethod\n    def bit_and(cls, x, y):\n        return x | y\n\n    @classmethod\n    def bit_or(cls, x, y):","productive":false,"mutation_operator":"BOR","equivalent":false,"mutated_output_lineno":100,"unmutated_output":"\n    @classmethod\n    def bit_negate(cls, x):\n        return ~x\n\n    @classmethod\n    def bit_and(cls, x, y):\n        return x & y\n\n    @classmethod\n    def bit_or(cls, x, y):","killers":[],"unmutated_output_lineno":100,"mutant_name":"mutant_BOR_BitAnd_80","killed":false,"mutated_ast_node":"BitAnd"},{"mutated_lineno":109,"mutated_output":"\n    @classmethod\n    def bit_and(cls, x, y):\n        return x & y\n\n    @classmethod\n    def bit_or(cls, x, y):\n        return x & y\n\n    @classmethod\n    def bit_xor(cls, x, y):","productive":false,"mutation_operator":"BOR","equivalent":false,"mutated_output_lineno":104,"unmutated_output":"\n    @classmethod\n    def bit_and(cls, x, y):\n        return x & y\n\n    @classmethod\n    def bit_or(cls, x, y):\n        return x | y\n\n    @classmethod\n    def bit_xor(cls, x, y):","killers":[],"unmutated_output_lineno":104,"mutant_name":"mutant_BOR_BitOr_81","killed":false,"mutated_ast_node":"BitOr"},{"mutated_lineno":113,"mutated_output":"\n    @classmethod\n    def bit_or(cls, x, y):\n        return x | y\n\n    @classmethod\n    def bit_xor(cls, x, y):\n        return x & y\n\n    @classmethod\n    def bit_left_shift(cls, x):","productive":false,"mutation_operator":"BOR","equivalent":false,"mutated_output_lineno":108,"unmutated_output":"\n    @classmethod\n    def bit_or(cls, x, y):\n        return x | y\n\n    @classmethod\n    def bit_xor(cls, x, y):\n        return x ^ y\n\n    @classmethod\n    def bit_left_shift(cls, x):","killers":[],"unmutated_output_lineno":108,"mutant_name":"mutant_BOR_BitXor_82","killed":false,"mutated_ast_node":"BitXor"},{"mutated_lineno":117,"mutated_output":"\n    @classmethod\n    def bit_xor(cls, x, y):\n        return x ^ y\n\n    @classmethod\n    def bit_left_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def bit_right_shift(cls, x):","productive":false,"mutation_operator":"BOR","equivalent":false,"mutated_output_lineno":112,"unmutated_output":"\n    @classmethod\n    def bit_xor(cls, x, y):\n        return x ^ y\n\n    @classmethod\n    def bit_left_shift(cls, x):\n        return x << 1\n\n    @classmethod\n    def bit_right_shift(cls, x):","killers":[],"unmutated_output_lineno":112,"mutant_name":"mutant_BOR_LShift_83","killed":false,"mutated_ast_node":"LShift"},{"mutated_lineno":121,"mutated_output":"\n    @classmethod\n    def bit_left_shift(cls, x):\n        return x << 1\n\n    @classmethod\n    def bit_right_shift(cls, x):\n        return x << 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):","productive":false,"mutation_operator":"BOR","equivalent":false,"mutated_output_lineno":116,"unmutated_output":"\n    @classmethod\n    def bit_left_shift(cls, x):\n        return x << 1\n\n    @classmethod\n    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):","killers":[],"unmutated_output_lineno":116,"mutant_name":"mutant_BOR_RShift_84","killed":false,"mutated_ast_node":"RShift"},{"mutated_lineno":38,"mutated_output":"        z = cls.multiply(x=not xx & yy, y=0)\n        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x // y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'","productive":false,"mutation_operator":"FHD","equivalent":false,"mutated_output_lineno":33,"unmutated_output":"        z = cls.multiply(x=not xx & yy, y=0)\n        return z\n\n    @classmethod\n    def floorDiv(cls, x, y):\n        try:\n            try:\n                quotient = x // y\n                return quotient\n            except ZeroDivisionError:\n                print 'divided by zero'","killers":[],"unmutated_output_lineno":33,"mutant_name":"mutant_FHD_TryFinally_85","killed":false,"mutated_ast_node":"TryFinally"},{"mutated_lineno":50,"mutated_output":"                print 'unknown exception'\n        finally:\n            pass\n\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x //= y","productive":false,"mutation_operator":"FHD","equivalent":false,"mutated_output_lineno":45,"unmutated_output":"                print 'unknown exception'\n        finally:\n            pass\n\n    @classmethod\n    def floorDivAssign(cls, x, y):\n        try:\n            try:\n                if y == 0 and True:\n                    return None\n                x //= y","killers":[],"unmutated_output_lineno":45,"mutant_name":"mutant_FHD_TryFinally_86","killed":false,"mutated_ast_node":"TryFinally"},{"mutated_lineno":81,"mutated_output":"        assert res >= 0\n        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n            break","productive":false,"mutation_operator":"OIL","equivalent":false,"mutated_output_lineno":76,"unmutated_output":"        assert res >= 0\n        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res","killers":[],"unmutated_output_lineno":76,"mutant_name":"mutant_OIL_While_87","killed":false,"mutated_ast_node":"While"},{"mutated_lineno":68,"mutated_output":"\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue","productive":false,"mutation_operator":"OIL","equivalent":false,"mutated_output_lineno":63,"unmutated_output":"\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue","killers":[],"unmutated_output_lineno":63,"mutant_name":"mutant_OIL_For_88","killed":false,"mutated_ast_node":"For"},{"mutated_lineno":127,"mutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n                break\n        return res","productive":false,"mutation_operator":"OIL","equivalent":false,"mutated_output_lineno":122,"unmutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n","killers":[],"unmutated_output_lineno":122,"mutant_name":"mutant_OIL_For_89","killed":false,"mutated_ast_node":"For"},{"mutated_lineno":68,"mutated_output":"\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in reversed(xrange(n)):\n            flag = nums[i] == 0\n            if flag:\n                continue","productive":false,"mutation_operator":"RIL","equivalent":false,"mutated_output_lineno":63,"unmutated_output":"\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue","killers":[],"unmutated_output_lineno":63,"mutant_name":"mutant_RIL_For_90","killed":false,"mutated_ast_node":"For"},{"mutated_lineno":127,"mutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in reversed(nums[start:end:step]):\n                res += anum\n        return res\n","productive":false,"mutation_operator":"RIL","equivalent":false,"mutated_output_lineno":122,"unmutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n","killers":[],"unmutated_output_lineno":122,"mutant_name":"mutant_RIL_For_91","killed":false,"mutated_ast_node":"For"},{"mutated_lineno":20,"mutated_output":"        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y >= 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod","productive":false,"mutation_operator":"COR","equivalent":false,"mutated_output_lineno":15,"unmutated_output":"        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod","killers":[["test_div (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 24, in test_div\n    self.assertEqual(self.sut.divide(operand1, operand2), 0, \"Incorrect Calculator.divide.\")\nAssertionError: Incorrect Calculator.divide.\n"]],"unmutated_output_lineno":15,"mutant_name":"mutant_COR_Eq_92","killed":true,"mutated_ast_node":"Eq"},{"mutated_lineno":20,"mutated_output":"        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y <= 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod","productive":false,"mutation_operator":"COR","equivalent":false,"mutated_output_lineno":15,"unmutated_output":"        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod","killers":[],"unmutated_output_lineno":15,"mutant_name":"mutant_COR_Eq_93","killed":false,"mutated_ast_node":"Eq"},{"mutated_lineno":20,"mutated_output":"        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y > 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod","productive":false,"mutation_operator":"COR","equivalent":false,"mutated_output_lineno":15,"unmutated_output":"        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod","killers":[["test_div (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 24, in test_div\n    self.assertEqual(self.sut.divide(operand1, operand2), 0, \"Incorrect Calculator.divide.\")\nAssertionError: Incorrect Calculator.divide.\n"]],"unmutated_output_lineno":15,"mutant_name":"mutant_COR_Eq_94","killed":true,"mutated_ast_node":"Eq"},{"mutated_lineno":20,"mutated_output":"        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y < 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod","productive":false,"mutation_operator":"COR","equivalent":false,"mutated_output_lineno":15,"unmutated_output":"        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod","killers":[],"unmutated_output_lineno":15,"mutant_name":"mutant_COR_Eq_95","killed":false,"mutated_ast_node":"Eq"},{"mutated_lineno":20,"mutated_output":"        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y != 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod","productive":false,"mutation_operator":"COR","equivalent":false,"mutated_output_lineno":15,"unmutated_output":"        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x / y\n        return quotient\n\n    @classmethod","killers":[["test_div (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 24, in test_div\n    self.assertEqual(self.sut.divide(operand1, operand2), 0, \"Incorrect Calculator.divide.\")\nAssertionError: Incorrect Calculator.divide.\n"]],"unmutated_output_lineno":15,"mutant_name":"mutant_COR_Eq_96","killed":true,"mutated_ast_node":"Eq"},{"mutated_lineno":127,"mutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[:end:step]:\n                res += anum\n        return res\n","productive":false,"mutation_operator":"SSID","equivalent":false,"mutated_output_lineno":122,"unmutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n","killers":[],"unmutated_output_lineno":122,"mutant_name":"mutant_SSID_Slice_97","killed":false,"mutated_ast_node":"Slice"},{"mutated_lineno":127,"mutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start::step]:\n                res += anum\n        return res\n","productive":false,"mutation_operator":"SEID","equivalent":false,"mutated_output_lineno":122,"unmutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n","killers":[],"unmutated_output_lineno":122,"mutant_name":"mutant_SEID_Slice_98","killed":false,"mutated_ast_node":"Slice"},{"mutated_lineno":127,"mutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end]:\n                res += anum\n        return res\n","productive":false,"mutation_operator":"STID","equivalent":false,"mutated_output_lineno":122,"unmutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n","killers":[],"unmutated_output_lineno":122,"mutant_name":"mutant_STID_Slice_99","killed":false,"mutated_ast_node":"Slice"},{"mutated_lineno":181,"mutated_output":"        self.name = 'name_value'\n        text = self.name\n\n    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    pass\n    nums = [4, 3, 1, 5, 2, 6]","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":176,"unmutated_output":"        self.name = 'name_value'\n        text = self.name\n\n    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]","killers":[],"unmutated_output_lineno":176,"mutant_name":"mutant_SMD_Expr_100","killed":false,"mutated_ast_node":"Expr"},{"mutated_lineno":181,"mutated_output":"        self.name = 'name_value'\n        text = self.name\n\n    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":176,"unmutated_output":"        self.name = 'name_value'\n        text = self.name\n\n    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]","killers":[],"unmutated_output_lineno":176,"mutant_name":"mutant_SMD_Expr_101","killed":false,"mutated_ast_node":"Expr"},{"mutated_lineno":3,"mutated_output":"class Calculator(object):\n\n    @classmethod\n    def add(cls, x, y):\n        pass\n        return sum\n\n    @classmethod","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":1,"unmutated_output":"class Calculator(object):\n\n    @classmethod\n    def add(cls, x, y):\n        sum = x + y\n        return sum\n\n    @classmethod","killers":[["test_add (unittest_calculator.CalculatorTestCases)","Traceback (most recent call last):\n  File \"C:\\Users\\sy64\\Documents\\590\\muupi\\sample\\unittest_calculator.py\", line 12, in test_add\n    self.assertEqual(self.sut.add(operand1, operand2), 9, \"Incorrect Calculator.add.\")\nAssertionError: Incorrect Calculator.add.\n"]],"unmutated_output_lineno":1,"mutant_name":"mutant_SMD_Assign_102","killed":true,"mutated_ast_node":"Assign"},{"mutated_lineno":8,"mutated_output":"    @classmethod\n    def add(cls, x, y):\n        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        pass\n        return diff\n\n    @classmethod","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":3,"unmutated_output":"    @classmethod\n    def add(cls, x, y):\n        sum = x + y\n        return sum\n\n    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y\n        return diff\n\n    @classmethod","killers":[],"unmutated_output_lineno":3,"mutant_name":"mutant_SMD_Assign_103","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":13,"mutated_output":"    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        pass\n        return product\n\n    @classmethod","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":8,"unmutated_output":"    @classmethod\n    def subtract(cls, x, y):\n        diff = x - y\n        return diff\n\n    @classmethod\n    def multiply(cls, x, y):\n        product = x * y\n        return product\n\n    @classmethod","killers":[],"unmutated_output_lineno":8,"mutant_name":"mutant_SMD_Assign_104","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":18,"mutated_output":"    @classmethod\n    def multiply(cls, x, y):\n        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        pass\n        return quotient","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":13,"unmutated_output":"    @classmethod\n    def multiply(cls, x, y):\n        product = x * y\n        return product\n\n    @classmethod\n    def divide(cls, x, y):\n        if y == 0:\n            return None\n        quotient = x / y\n        return quotient","killers":[],"unmutated_output_lineno":13,"mutant_name":"mutant_SMD_Assign_105","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":29,"mutated_output":"\n    @classmethod\n    def negate(cls, x):\n        return -x\n\n    @classmethod\n    def test_op1(cls):\n        pass\n        yy = 3\n        z = cls.multiply(x=not xx & yy, y=0)\n        return z","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":24,"unmutated_output":"\n    @classmethod\n    def negate(cls, x):\n        return -x\n\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3\n        z = cls.multiply(x=not xx & yy, y=0)\n        return z","killers":[],"unmutated_output_lineno":24,"mutant_name":"mutant_SMD_Assign_106","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":29,"mutated_output":"\n    @classmethod\n    def negate(cls, x):\n        return -x\n\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        pass\n        z = cls.multiply(x=not xx & yy, y=0)\n        return z","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":24,"unmutated_output":"\n    @classmethod\n    def negate(cls, x):\n        return -x\n\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3\n        z = cls.multiply(x=not xx & yy, y=0)\n        return z","killers":[],"unmutated_output_lineno":24,"mutant_name":"mutant_SMD_Assign_107","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":29,"mutated_output":"\n    @classmethod\n    def negate(cls, x):\n        return -x\n\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3\n        pass\n        return z","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":24,"unmutated_output":"\n    @classmethod\n    def negate(cls, x):\n        return -x\n\n    @classmethod\n    def test_op1(cls):\n        xx = 2\n        yy = 3\n        z = cls.multiply(x=not xx & yy, y=0)\n        return z","killers":[],"unmutated_output_lineno":24,"mutant_name":"mutant_SMD_Assign_108","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":62,"mutated_output":"            except ZeroDivisionError:\n                print 'divided by zero'\n            except:\n                print 'unknown exception'\n        finally:\n            pass\n\n    @classmethod\n    def sum_all(cls, nums):\n        pass\n        if not n > 0:","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":57,"unmutated_output":"            except ZeroDivisionError:\n                print 'divided by zero'\n            except:\n                print 'unknown exception'\n        finally:\n            pass\n\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:","killers":[],"unmutated_output_lineno":57,"mutant_name":"mutant_SMD_Assign_109","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":62,"mutated_output":"            except ZeroDivisionError:\n                print 'divided by zero'\n            except:\n                print 'unknown exception'\n        finally:\n            pass\n\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":57,"unmutated_output":"            except ZeroDivisionError:\n                print 'divided by zero'\n            except:\n                print 'unknown exception'\n        finally:\n            pass\n\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:","killers":[],"unmutated_output_lineno":57,"mutant_name":"mutant_SMD_Assign_110","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":68,"mutated_output":"\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            pass\n            if flag:\n                continue","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":63,"unmutated_output":"\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue","killers":[],"unmutated_output_lineno":63,"mutant_name":"mutant_SMD_Assign_111","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":68,"mutated_output":"\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":63,"unmutated_output":"\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue","killers":[],"unmutated_output_lineno":63,"mutant_name":"mutant_SMD_Assign_112","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":77,"mutated_output":"            if flag:\n                continue\n            res += nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        pass\n        i = 0","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":72,"unmutated_output":"            if flag:\n                continue\n            res += nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0","killers":[],"unmutated_output_lineno":72,"mutant_name":"mutant_SMD_Assign_113","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":77,"mutated_output":"            if flag:\n                continue\n            res += nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        pass","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":72,"unmutated_output":"            if flag:\n                continue\n            res += nums[i]\n            res = cls.add(res, nums[i])\n        assert res >= 0\n        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0","killers":[],"unmutated_output_lineno":72,"mutant_name":"mutant_SMD_Assign_114","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":86,"mutated_output":"        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n\n    @classmethod\n    def get_version(cls):\n        pass\n        return version","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":81,"unmutated_output":"        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n\n    @classmethod\n    def get_version(cls):\n        version = '1.2.3'\n        return version","killers":[],"unmutated_output_lineno":81,"mutant_name":"mutant_SMD_Assign_115","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":93,"mutated_output":"    @classmethod\n    def get_version(cls):\n        version = '1.2.3'\n        return version\n\n    @classmethod\n    def divide_positiveInt(cls, x, y):\n        if x >= y > 0:\n            pass\n            return quotient\n        else:","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":88,"unmutated_output":"    @classmethod\n    def get_version(cls):\n        version = '1.2.3'\n        return version\n\n    @classmethod\n    def divide_positiveInt(cls, x, y):\n        if x >= y > 0:\n            quotient = x / y\n            return quotient\n        else:","killers":[],"unmutated_output_lineno":88,"mutant_name":"mutant_SMD_Assign_116","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":123,"mutated_output":"    def bit_left_shift(cls, x):\n        return x << 1\n\n    @classmethod\n    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        pass\n        if len(nums) > 0:","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":118,"unmutated_output":"    def bit_left_shift(cls, x):\n        return x << 1\n\n    @classmethod\n    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:","killers":[],"unmutated_output_lineno":118,"mutant_name":"mutant_SMD_Assign_117","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":173,"mutated_output":"        :return:\n        \"\"\"\n        return x / y\n\n\nclass CalculatorTest(object):\n\n    def __init__(self):\n        pass\n        text = self.name\n","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":168,"unmutated_output":"        :return:\n        \"\"\"\n        return x / y\n\n\nclass CalculatorTest(object):\n\n    def __init__(self):\n        self.name = 'name_value'\n        text = self.name\n","killers":[],"unmutated_output_lineno":168,"mutant_name":"mutant_SMD_Assign_118","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":173,"mutated_output":"        :return:\n        \"\"\"\n        return x / y\n\n\nclass CalculatorTest(object):\n\n    def __init__(self):\n        self.name = 'name_value'\n        pass\n","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":168,"unmutated_output":"        :return:\n        \"\"\"\n        return x / y\n\n\nclass CalculatorTest(object):\n\n    def __init__(self):\n        self.name = 'name_value'\n        text = self.name\n","killers":[],"unmutated_output_lineno":168,"mutant_name":"mutant_SMD_Assign_119","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":181,"mutated_output":"        self.name = 'name_value'\n        text = self.name\n\n    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    pass\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":176,"unmutated_output":"        self.name = 'name_value'\n        text = self.name\n\n    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]","killers":[],"unmutated_output_lineno":176,"mutant_name":"mutant_SMD_Assign_120","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":181,"mutated_output":"        self.name = 'name_value'\n        text = self.name\n\n    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    pass","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":176,"unmutated_output":"        self.name = 'name_value'\n        text = self.name\n\n    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]","killers":[],"unmutated_output_lineno":176,"mutant_name":"mutant_SMD_Assign_121","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":181,"mutated_output":"        self.name = 'name_value'\n        text = self.name\n\n    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":176,"unmutated_output":"        self.name = 'name_value'\n        text = self.name\n\n    def get_name(self):\n        return self.name\n\n\nif __name__ == '__main__':\n    res = Calculator.floorDiv(5, 2)\n    Calculator.add(5, 5)\n    nums = [4, 3, 1, 5, 2, 6]","killers":[],"unmutated_output_lineno":176,"mutant_name":"mutant_SMD_Assign_122","killed":false,"mutated_ast_node":"Assign"},{"mutated_lineno":68,"mutated_output":"\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":63,"unmutated_output":"\n    @classmethod\n    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue","killers":[],"unmutated_output_lineno":63,"mutant_name":"mutant_SMD_AugAssign_123","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":81,"mutated_output":"        assert res >= 0\n        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            pass\n            i += 1\n        return res","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":76,"unmutated_output":"        assert res >= 0\n        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res","killers":[],"unmutated_output_lineno":76,"mutant_name":"mutant_SMD_AugAssign_124","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":81,"mutated_output":"        assert res >= 0\n        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            pass\n        return res","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":76,"unmutated_output":"        assert res >= 0\n        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res","killers":[],"unmutated_output_lineno":76,"mutant_name":"mutant_SMD_AugAssign_125","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":127,"mutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                pass\n        return res\n","productive":false,"mutation_operator":"SMD","equivalent":false,"mutated_output_lineno":122,"unmutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n","killers":[],"unmutated_output_lineno":122,"mutant_name":"mutant_SMD_AugAssign_126","killed":false,"mutated_ast_node":"AugAssign"},{"mutated_lineno":70,"mutated_output":"    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            break\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res += nums[i]","productive":false,"mutation_operator":"ZIL","equivalent":false,"mutated_output_lineno":65,"unmutated_output":"    def sum_all(cls, nums):\n        n = len(nums)\n        if not n > 0:\n            return 0\n        res = 0\n        for i in xrange(n):\n            flag = nums[i] == 0\n            if flag:\n                continue\n            res += nums[i]\n            res = cls.add(res, nums[i])","killers":[],"unmutated_output_lineno":65,"mutant_name":"mutant_ZIL_For_127","killed":false,"mutated_ast_node":"For"},{"mutated_lineno":127,"mutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                break\n                res += anum\n        return res","productive":false,"mutation_operator":"ZIL","equivalent":false,"mutated_output_lineno":122,"unmutated_output":"    def bit_right_shift(cls, x):\n        return x >> 1\n\n    @classmethod\n    def sum_of_collection(cls, nums, start, end, step):\n        res = 0\n        if len(nums) > 0:\n            for anum in nums[start:end:step]:\n                res += anum\n        return res\n","killers":[],"unmutated_output_lineno":122,"mutant_name":"mutant_ZIL_For_128","killed":false,"mutated_ast_node":"For"},{"mutated_lineno":82,"mutated_output":"        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            break\n            res += nums[i]\n            i += 1\n        return res","productive":false,"mutation_operator":"ZIL","equivalent":false,"mutated_output_lineno":77,"unmutated_output":"        return res\n\n    @classmethod\n    def sum_all_while(cls, nums):\n        res = 0\n        i = 0\n        while i < len(nums):\n            res += nums[i]\n            i += 1\n        return res\n","killers":[],"unmutated_output_lineno":77,"mutant_name":"mutant_ZIL_While_129","killed":false,"mutated_ast_node":"While"}]